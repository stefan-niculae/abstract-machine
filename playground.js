// Generated by CoffeeScript 1.12.4
(function() {
  var clone, emptyState, func, isa, jasmine, trans,
    slice = [].slice;

  jasmine = require('jasmine');

  func = {
    '+': function(a, b) {
      return a + b;
    },
    '-': function(a, b) {
      return a - b;
    },
    '*': function(a, b) {
      return a * b;
    },
    '/': function(a, b) {
      return a / b;
    },
    '%': function(a, b) {
      return a % b;
    },
    '==': function(a, b) {
      return a === b;
    },
    '!=': function(a, b) {
      return a !== b;
    },
    '<': function(a, b) {
      return a < b;
    },
    '<=': function(a, b) {
      return a <= b;
    },
    '>': function(a, b) {
      return a > b;
    },
    '>=': function(a, b) {
      return a >= b;
    }
  };

  isa = function(x, type) {
    if (type === 'iop') {
      return x === '+' || x === '-' || x === '*' || x === '/' || x === '%';
    }
    if (type === 'bop') {
      return x === '==' || x === '!=' || x === '<' || x === '<=' || x === '>' || x === '>=';
    }
    return false;
  };

  clone = function(obj) {
    var cloned, key;
    cloned = {};
    for (key in obj) {
      cloned[key] = obj[key];
    }
    return cloned;
  };

  trans = function(arg) {
    var b, body, c, cf, comm, cond, ct, f, h, loopAgain, m, n, n1, n2, newMem, ref, ref1, s, st, t, v, whileStmt;
    c = arg.c, s = arg.s, m = arg.m;
    h = c[0], t = 2 <= c.length ? slice.call(c, 1) : [];
    if ((ref = typeof h) === 'number' || ref === 'boolean') {
      return {
        c: t,
        s: [h].concat(slice.call(s)),
        m: m
      };
    }
    if (h.type === 'valof') {
      if (!(h["var"] in m)) {
        throw new Error(h["var"] + " is undefined");
      }
      n = m[h["var"]];
      return {
        c: t,
        s: [n].concat(slice.call(s)),
        m: m
      };
    }
    if ((ref1 = h.type) === 'expr' || ref1 === 'cond') {
      return {
        c: [h.e1, h.e2, h.op].concat(slice.call(t)),
        s: s,
        m: m
      };
    }
    if (isa(h, 'iop') || isa(h, 'bop')) {
      n2 = s[0], n1 = s[1], st = 3 <= s.length ? slice.call(s, 2) : [];
      f = func[h];
      n = f(n1, n2);
      return {
        c: t,
        s: [n].concat(slice.call(st)),
        m: m
      };
    }
    if (h === '()') {
      return {
        c: t,
        s: s,
        m: m
      };
    }
    if (h.type === 'assign') {
      return {
        c: [h.val, ':='].concat(slice.call(t)),
        s: [h["var"]].concat(slice.call(s)),
        m: m
      };
    }
    if (h === ':=') {
      n = s[0], v = s[1], st = 3 <= s.length ? slice.call(s, 2) : [];
      newMem = clone(m);
      newMem[v] = n;
      return {
        c: t,
        s: st,
        m: newMem
      };
    }
    if (h.type === 'if') {
      return {
        c: [h.cond, 'branch'].concat(slice.call(t)),
        s: [h.ct, h.cf].concat(slice.call(s)),
        m: m
      };
    }
    if (h === 'branch') {
      b = s[0], ct = s[1], cf = s[2], st = 4 <= s.length ? slice.call(s, 3) : [];
      comm = b ? ct : cf;
      return {
        c: [comm].concat(slice.call(t)),
        s: st,
        m: m
      };
    }
    if (h.type === 'seq') {
      return {
        c: [h.s1, h.s2].concat(slice.call(t)),
        s: s,
        m: m
      };
    }
    if (h.type === 'while') {
      return {
        c: [h.cond, 'loop'].concat(slice.call(t)),
        s: [h.cond, h.body].concat(slice.call(s)),
        m: m
      };
    }
    if (h === 'loop') {
      loopAgain = s[0], cond = s[1], body = s[2], st = 4 <= s.length ? slice.call(s, 3) : [];
      if (loopAgain) {
        whileStmt = {
          type: 'while',
          cond: cond,
          body: body
        };
        return {
          c: [cond, whileStmt].concat(slice.call(t)),
          s: st,
          m: m
        };
      } else {
        return {
          c: t,
          s: st,
          m: m
        };
      }
    }
  };

  emptyState = {
    c: [],
    s: [],
    m: {}
  };

  module.exports = trans;

}).call(this);
