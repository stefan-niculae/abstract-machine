# number literal
7
    7

# float literal
1.5
    1.5

# bool literal
false
    false

# skip
()
    "()"

# deref
!var
    type: 'valof'
    var: var

# assign
var := 0
    type: "assign"
    var: "var"
    val: 0

# keyword assign !!!
false := 5
    reserved keyword error

# keyword deref !!!
!if < 5
    reserved keyword error

# boolean cond
0 < 1
    type: "cond"
    e1: 0
    op: "<"
    e2: 1

# arith expr
1 + 2
    type: "expr"
    e1: 1
    op: "+"
    e2: 2

# sequence
x := 0; ()
    type: "seq"
    s1:
        type: "assign"
        var: "x"
        val: 0
    s2: "()"

# seq with newlines
x := 0;
y := 1
    type: "seq"
    s1:
        type: "assign"
        var: "x"
        val: 0
    s2:
        type: "assign"
        var: "y"
        val: 1

# if
if true then () else x := 0
    type: "if"
    cond: true
    st: "()"
    sf:
        type: "assign"
        var: "x"
        val: 0

# while
while false do ()
    type: "while"
    cond: false
    body: "()"

# nested control
while false do if true then () else ()
    type: "while"
    cond: false
    body:
        type: "if"
        cond: true
        st: "()"
        sf: "()"

# assign expr
x := !y + 1
    type: "assign"
    var: "x"
    val:
        type: "expr"
        e1:
            type: "valof"
            var: "y"
        op: "+"
        e2: 1


# ooo !!!
4 + 6/2
    type: "expr"
    e1: 4
    op: '+'
    type: 'expr'
        e1: 6
        op: '/'
        e2: 2

# ooo parens workaround
4 + (6/2)
    type: "expr"
    e1: 4
    op: '+'
    type: 'expr'
        e1: 6
        op: '/'
        e2: 2

#ooo2
4/2 + 6
    type: 'expr'
    e1:
        type: 'expr'
        e1: 4
        op: '/'
        e2: 2
    op: '+'
    e2: 6


# ooo3
10 / 2 * 4
    type: "expr"
    e1:
        type: "expr"
        e1: 10
        op: "/"
        e2: 2
    op: "*"
    e2: 4

# ooo parens
(10+10) / 2
    type 'expr'
        e1:
            type: 'expr'
            e1: 10
            op: '+'
            e2: 10
        op: '/'
        e2: 2


# complex p1
while 0 <= !x do ()
    type: "while"
        cond:
        type: "cond"
        e1: 0
        op: "<="
        e2:
            type: "valof"
            var: "x"
    body: "()"

# complex p2
sum := !sum + !x
    type: "assign"
    var: "sum"
    val:
        type: "expr"
        e1:
            type: "valof"
            var: "sum"
        op: "+"
        e2:
            type: "valof"
            var: "x"

# complex3
x := !x - 1
    type: "assign"
    var: "x"
    val:
        type: "expr"
        e1:
            type: "valof"
            var: "x"
            op: "-"
        e2: 1

# complex4
while 0<=!x do {
    sum:=!sum+!x;
    x:=!x-1
}


# while no braces
while true do
    ();
()

    type: "seq"
    s1:
        type: "while"
        cond: true
        body: "()"
    s2: "()"


# while braces
while true do {
    ();
    ()
}

    type: "while"
    cond: true
    body:
        type: 'seq'
        s1: '()'
        s2: '()'


# newlines
x := !x + 1;

y := !y + 2
