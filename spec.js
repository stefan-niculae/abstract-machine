// Generated by CoffeeScript 1.12.4
(function() {
  var trans;

  trans = require('./evaluator');

  describe('The transition function for int expressions', function() {
    it('can move an int from c to s', function() {
      var state;
      state = {
        c: [1, '()'],
        s: [8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [1, 8],
        m: {}
      });
    });
    it('can put the value of a var from m in s', function() {
      var state;
      state = {
        c: [
          {
            type: 'valof',
            "var": 'x'
          }, '()'
        ],
        s: [8],
        m: {
          x: 1,
          y: 2
        }
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [1, 8],
        m: {
          x: 1,
          y: 2
        }
      });
    });
    it('throws an exception on undefined var', function() {
      var state;
      state = {
        c: [
          {
            type: 'valof',
            "var": 'x'
          }
        ],
        s: [],
        m: {}
      };
      return expect(function() {
        return trans(state);
      }).toThrowError('x is undefined');
    });
    it('can transform an expression into post-fix form', function() {
      var state;
      state = {
        c: [
          {
            type: 'expr',
            e1: 1,
            op: '+',
            e2: 2
          }, '()'
        ],
        s: [],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [1, 2, '+', '()'],
        s: [],
        m: {}
      });
    });
    it('can do addition', function() {
      var state;
      state = {
        c: ['+', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [3],
        m: {}
      });
    });
    it('can do subtraction', function() {
      var state;
      state = {
        c: ['-', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [-1],
        m: {}
      });
    });
    it('can do multiplication', function() {
      var state;
      state = {
        c: ['*', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [2],
        m: {}
      });
    });
    it('can do division', function() {
      var state;
      state = {
        c: ['/', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [0.5],
        m: {}
      });
    });
    return it('can do modulus', function() {
      var state;
      state = {
        c: ['%', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [1],
        m: {}
      });
    });
  });

  describe('The transition function for bool conditions', function() {
    it('can move a bool from c to s', function() {
      var state;
      state = {
        c: [true, '()'],
        s: [8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [true, 8],
        m: {}
      });
    });
    it('can transform a condition into post-fix form', function() {
      var state;
      state = {
        c: [
          {
            type: 'cond',
            e1: 1,
            op: '<',
            e2: 2
          }, '()'
        ],
        s: [],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [1, 2, '<', '()'],
        s: [],
        m: {}
      });
    });
    it('can do eq comparison', function() {
      var state;
      state = {
        c: ['==', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [false],
        m: {}
      });
    });
    it('can do neq comparison', function() {
      var state;
      state = {
        c: ['!=', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [true],
        m: {}
      });
    });
    it('can do lt comparison', function() {
      var state;
      state = {
        c: ['<', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [true],
        m: {}
      });
    });
    it('can do lte comparison', function() {
      var state;
      state = {
        c: ['<=', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [true],
        m: {}
      });
    });
    it('can do gt comparison', function() {
      var state;
      state = {
        c: ['>', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [false],
        m: {}
      });
    });
    return it('can do gte comparison', function() {
      var state;
      state = {
        c: ['>=', '()'],
        s: [2, 1],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [false],
        m: {}
      });
    });
  });

  describe('The transition function for commands', function() {
    it('can skip', function() {
      var state;
      state = {
        c: ['()', '()'],
        s: [],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [],
        m: {}
      });
    });
    it('can disperse an assignment statement to c and s', function() {
      var state;
      state = {
        c: [
          {
            type: 'assign',
            "var": 'x',
            val: 1
          }, '()'
        ],
        s: [8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [1, ':=', '()'],
        s: ['x', 8],
        m: {}
      });
    });
    it('can assign in memory', function() {
      var state;
      state = {
        c: [':=', '()'],
        s: [1, 'x', 8],
        m: {
          y: 2
        }
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [8],
        m: {
          x: 1,
          y: 2
        }
      });
    });
    return it('can sequence statements', function() {
      var assignment, state;
      assignment = {
        type: 'assign',
        "var": 'x',
        val: 1
      };
      state = {
        c: [
          {
            type: 'seq',
            s1: '()',
            s2: assignment
          }, '()'
        ],
        s: [],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()', assignment, '()'],
        s: [],
        m: {}
      });
    });
  });

  describe('The transition function for branching and looping', function() {
    it('can disperse an if statements to c and s', function() {
      var assignment, state;
      assignment = {
        type: 'assign',
        "var": 'x',
        val: 1
      };
      state = {
        c: [
          {
            type: 'if',
            cond: true,
            st: '()',
            sf: assignment
          }, '()'
        ],
        s: [8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [true, 'branch', '()'],
        s: ['()', assignment, 8],
        m: {}
      });
    });
    it('can branch based on the top of the stack (true)', function() {
      var assignment, state;
      assignment = {
        type: 'assign',
        "var": 'x',
        val: 1
      };
      state = {
        c: ['branch', '()'],
        s: [true, '()', assignment, 8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()', '()'],
        s: [8],
        m: {}
      });
    });
    it('can branch based on the top of the stack (false)', function() {
      var assignment, state;
      assignment = {
        type: 'assign',
        "var": 'x',
        val: 1
      };
      state = {
        c: ['branch', '()'],
        s: [false, '()', assignment, 8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [assignment, '()'],
        s: [8],
        m: {}
      });
    });
    it('can disperse a while statement to c and s ', function() {
      var state;
      state = {
        c: [
          {
            type: 'while',
            cond: true,
            body: '()'
          }, '()'
        ],
        s: [8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [true, 'loop', '()'],
        s: [true, '()', 8],
        m: {}
      });
    });
    it('can loop when the top of the stack is false', function() {
      var cond, state;
      cond = {
        type: 'cond',
        e1: 1,
        op: '<',
        e2: 2
      };
      state = {
        c: ['loop', '()'],
        s: [false, cond, '()', 8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: ['()'],
        s: [8],
        m: {}
      });
    });
    return it('can loop when the top of the stack is true', function() {
      var cond, state;
      cond = {
        type: 'cond',
        e1: 1,
        op: '<',
        e2: 2
      };
      state = {
        c: ['loop', '()'],
        s: [true, cond, '()', 8],
        m: {}
      };
      return expect(trans(state)).toEqual({
        c: [
          cond, {
            type: 'while',
            cond: cond,
            body: '()'
          }, '()'
        ],
        s: [8],
        m: {}
      });
    });
  });

}).call(this);
